---
layout: single
title:  "Day 37 학습정리"
categories: boostcamp-note-week8
sidebar:
  nav: "docs"
---

23/12/27 (수) 학습 내용

<h1>AI 서비스 개발 기초</h1>

<h2>(4강) Docker 입문</h2>
- 강의 키워드<br><br>
: - 컨테이너화(Containerization)
: - 이미지 및 컨테이너 관리(Image and Container Management)
: - 도커(Docker) 기초
<br><br>

- Docker 소개<br><br>
: <br><b>가상화란?</b><br><br>
: : 개발할 때, 서비스 운영에 사용하는 서버에 직접 들어가서 개발하지 않음
: : Local 환경에서 개발하고, 완료되면 Staging 서버, Production 서버에 배포
: : 개발 진행한 Local 환경과 Production 서버 환경이 다른 경우 (ex. 로컬은 맥, 프로덕션은 리눅스)
: : OS가 다르기 때문에 라이브러리, 파이썬 등 설치할 때 다르게 해야 함
: : Local의 환경 변수, Production 서버의 환경 변수(Env)가 겹치거나 꼬일 수 있음
: : 사용자 그룹, Permission이 다를 수 있음
: : ex) 운영하고 있는 서버가 100대라면? => 특정 서버 업데이트가 진행되었다면 나머지 서버도 모두 업데이트 해야 함
<br><br>
: : 고민 -> 서버 환경까지도 모두 한번에 소프트웨어화 할 수 없을까?
: : 이를 해결하기 위해 나온 개념이 "가상화" (여기서는 소프트웨어 가상화)
: : Research / Production 환경에서 공통적으로 사용하는 일종의 템플릿
: <br><b>Docker 등장하기 전</b><br><br>
: : 주로 VM(Virtual Machine)을 사용
: : 호스트 머신이라고 하는 실제 물리적 컴퓨터 위에, OS를 포함한 가상화 소프트웨어를 두는 방식
: : OS를 포함하기 때문에, 조금 무겁다는 이슈가 있었음
: : GCP의 Compute Engine, 또는 AWS EC2가 이런 개념을 활용
: : Container : VM의 무거움을 크게 덜어주면서, 가상화를 좀 더 경량화된 프로세스의 개념으로 만든 기술
: <br><b>Docker 소개</b><br><br>
: : Container 기술을 쉽게 사용할 수 있도록 나온 도구가 바로 Docker
<br><br>
: : <u>Docker Image</u>
: : 컨테이너를 실행할 때 사용할 수 있는 템플릿
: : Read Only
<br><br>
: : <u>Docker Container</u>
: : Docker Image를 활용해 실행된 인스턴스
: : Write 가능
: <br><b>Docker로 할 수 있는 일</b><br><br>
: : 다른 사람이 만든 소프트웨어를 가져와서 바로 사용 가능 (ex. MySQL, Jupyter Notebook을 Docker로 실행)
: : 다른 사람이 만든 소프트웨어 -> Docker Image
: : OS, 설정을 포함한 실행 환경
: : Linux, Windows, Mac 어디서나 동일하게 실행 가능
: : 자신만의 이미지를 만들면 다른 사람에게 공유 가능
: : 원격 저장소 -> Container Registry
: : 회사에서 서비스를 배포할 때는 원격 저장소에 이미지를 업로드하고, 서버에서 받아서 실행하는 식으로 진행
: : dockerhub, GCR, ECR 등
<br><br>

- Docker 실습<br><br>
: <br><b>설치하고 실행하기</b><br><br>
: : docker run 할 때 파일 공유하는 방법
: : <u>Volume Mount</u>
: : 만약 파일을 유지하고 싶다면, Host와 Container의 저장소를 공유해야 함
: : -v 옵션을 사용하며, -p처럼 사용함 (-v Host_Folder:Container_Folder)
: : ex) docker run -it -p 8888:8888 -v /some/host/folder/for/work:/home/jovyan/workspace/jupyter/minimal-notebook
<br><br>
: : dockerhub에서 공개된 모든 이미지를 다운받을 수 있음
: : MySQL도 Dockerhub에서 다운로드
: : 웬만한 오픈소스들이 공개되어 있고, 필요한 이미지를 찾아 실행하는 것
: <br><b>Docker Image 만들기</b><br><br>
: : 보통 처음부터 만들지 않고, 이미 공개된 이미지를 기반으로 새로운 설정 추가
: : 실제 사용할 때 강의자료 참고해서 해보기
: <br><b>Registry에 Docker Image Push</b><br><br>
: : 본 강의에서는 Dockerhub 사용


<h2>(5강) 디버깅 Case Study</h2>
- 강의 키워드<br><br>
: - 디버깅 기술(Debugging Techniques)
: - 문제 해결 및 오류 분석(Problem Solving & Error Analysis)

- 개발 과정의 디버깅<br><br>
: <br><b>디버깅이란?</b><br><br>
: : 오류나 버그를 찾고 수정하는 과정
: : 사람의 실수, 실행 환경, 의존성, 복잡성, 커뮤니케이션 과정의 실수 등으로 인해 발생할 수 있다.
: <br><b>디버깅 Process</b><br><br>
: : 1) 문제 발생
: : 2) 문제 인식 : 문제 상황 확인, 어떤 상황인가? 재현이 되는가?
: : 오류 분류하기 - 어떤 오류인가? 오류 메시지 읽기 (코드 오류, 인프라 오류, 알 수 없는 오류 등)
: : 3) 해결책 찾기
: : 과거에 경험한 문제인가? -> 오답 노트를 찾아본다
: : 아니면, 해결책 검색 시작 (구글, Stackoverflow, 오픈카톡방, 공식 문서, Github Issue, ChatGPT) -> 오픈소스라면 코드 확인
: : 기록 - 오답노트 (블로그 등에 기록해놓는다. 나의 경우 워드로 만들어놓은 파일을 블로그에 카테고리별로 정리해서 올려보자.)
<br><br>
: : 무엇이 문제인지 아는 것이 중요
: : 실행 환경 - OS, 가상환경 여부, 사용하는 라이브러리 버전
: : 재현 가능하도록 준비해야 누군가에게 질문 가능
: : 오류 메시지를 꼭 잘 읽기. 그냥 넘어가는 것이 아닌 제대로 읽어보기.
: : ChatGPT는 100% 정답을 내지 않는 것을 인지하고 사용해야 한다.
<br><br>
: : 마스터님의 실제 디버깅 과정 보며 따라가기
<br><br>

- 서버 관리 Case Study<br><br>
: <br><b>서버 관리</b><br><br>
: : AI, ML 엔지니어가 만든 모델은 대부분 서버에서 동작
: : 서버를 어떻게 관리할 수 있는지를 배울 필요 있음
: : 깊은 서버 관리가 아닌 간단한 서버 관리 다루며, 스스로 문제를 파악하는 디버깅 과정과 유사
: : 서버 관리의 목적은 서버를 안정적으로 운영해서 장애를 발생하지 않기 위함
: <br><b>파일 시스템, 디스크 용량</b><br><br>
: : Linux 파일 시스템 구성 (강의자료 참조)
: : bin, boot, opt, dev, home, lib 등
: : Linux도 잔여 디스크 용량이 속도에 영향을 미친다
: : df -h (파티션 단위 확인), du -h -d2 (폴더별로 확인) 
: : (-h는 Human-readable의 약자로, 사람이 보기 좋게 출력)
<br><br>
: Error: No space left on device
: : 원인 - 해당 머신에 남은 공간이 부족할 때
: : 사용하지 않는 파일들을 지워주되, 파일별로 확인하고 삭제
: : 서버가 어떤 환경에서 실행 중인지 확인 필요
<br><br>
: Error: No such file or directory
: : 원인 - 찾으려고 하는 파일이나 경로가 없을 때
: : 파일의 경로, 실제 존재 여부 등 확인
<br><br>
: <br><b>네트워크</b><br><br>
: : IP : 네트워크에 연결된 다른 컴퓨터의 주소
: : 16.144.223.21 같이 숫자로 설정
: : IP 주소는 어려우니 도메인을 구매해서 설정
: : DNS : 사람이 읽을 수 있는 도메인 이름 (예.www.amazon.com)을 컴퓨터가 읽을 수 있는 IP 주소(예: 192.0.2.44)로 변환
: : Port
: : 포트 숫자는 PC에 접속할 수 있는 통로
: : 예: localhost:8000, 8000번 포트로 접속
: : 포트를 개방해야 사용할 수 있음
<br><br>
: : 방화벽
: : 필수는 아니지만, OS에 특정 IP, Port만 접속할 수 있도록 설정
: : 보통 이런 IP, Port를 ACL(Access Control List) 혹은 White List라고 부름
: : ping
: : 서버가 연결되어 있는지, 얼마나 빠른 속도로 데이터가 전송되는지 테스트
: : 네트워크 상에서 서버에게 작은 패킷을 보내고, 서버가 이를 받았다는 신호를 받는 것으로 동작
: : ping + IP 주소나 도메인 이름을 입력함
: : ex) ping google.com
<br><br>
: : Error: 서버에 Jupyter Notebook을 실행했는데 웹에서 접속할 수 없는 경우
: : 원인 : 웹에서 접근이 되지 않음
: : 해결 방법
: : IP 주소 잘 작성했는지 확인
: : 네트워크 연결 확인 (ping, netstat으로 포트 확인)
: : Jupyter Notebook 실행시 해당 IP로 실행했는지 확인
: : 방화벽 확인
: : 로그 확인
: : 서버 과부하 여부를 확인
: : 디스크 용량이 가득 차서 오류가 발생할 수 있음
: : Docker 사용할 경우 Log파일이 자동으로 생성되어서 쌓이곤 하는데, 이것 때문에 용량이 가득 찰 수도 있다.
: : FastAPI 사용해 웹서버 만들었다면 여러 이유가 있을 수 있음(인프라 영역, DB, 프론트 등) -> 디버깅하며 하나씩 해결
: <br><b>성능 확인</b><br><br>
: : GPU, CPU, Memory의 성능을 확인하고 싶은 경우
: : AI 모델 학습 과정에서 사용하고 있는 리소스를 확인해야 할 수 있음 (너무 많이 사용하고 있다면 다른 작업 추가적으로 할 수 없으므로)
: : top이란 명령어로 확인 가능 (CPU, Memory)
: : glances, nvidia-smi도 GPU 사용량 확인 가능




<h2>Peer Session</h2>
- 1) 주제 1<br><br>
: : 
: : 
- 2) 주제 2<br><br>
: : 
: : 